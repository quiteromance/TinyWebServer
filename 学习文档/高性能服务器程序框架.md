# 高性能服务器框架

## 目录

- [高性能服务器框架](#高性能服务器框架)
  - [目录](#目录)
  - [1 服务器模型](#1-服务器模型)
    - [1.1 C/S模型](#11-cs模型)
    - [1.2 P2P模型](#12-p2p模型)
  - [2 服务器编程框架](#2-服务器编程框架)
  - [3 I/O模型](#3-io模型)

## 1 服务器模型

### 1.1 C/S模型

C/S模型（client/server模型）：客户端通过访问服务器来获取所需要的资源。C/S模型逻辑如下：

- 服务器启动后，首先创建一个（或多个）监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。
- 由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。I/O模型有多种，服务器使用的是I/O复用技术之一的select系统调用。当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。逻辑单元可以是新创建的子进程（子进程是由另一个进程（称为父进程）创建的独立执行单元。）、子线程或者其他。
- 逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。
- 客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连接，则服务器执行被动关闭连接。
- 服务器同时监听多个客户请求是通过select系统调用实现的。

C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。下面讨论的P2P模型解决了这个问题。

### 1.2 P2P模型

P2P（Peer to Peer，点对点）模型比C/S模型更符合网络通信的实际情况。它摒弃了以服务器为中心的格局，**让网络上所有主机重新回归对等的地位**。P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络的负载将加重。实际使用的P2P模型通常带有一个专门的发现服务器。这个发现服务器通常还提供查找服务（甚至还可以提供内容服务），使每个客户都能尽快地找到自己需要的资源。

## 2 服务器编程框架

服务器的基本框架包含：

- **I/O处理单元**：服务器管理客户连接的模块。数据的收发不一定在I/O处理单元中执行，也可能在逻辑单元中执行,它通常要完成以下工作：

  - 等待并接受新的客户连接
  - 接收客户数据
  - 将服务器响应数据返回给客户端
  - 对于一个**服务器机群**来说，I/O处理单元是一个专门的接入服务器。它**实现负载均衡**，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。

- **逻辑单元**：通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端。对服务器机群而言，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理。
- **网络存储单元**：可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。
- **请求队列**：是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开销。

## 3 I/O模型

- socket在创建的时候默认是阻塞的，我们可以将其设置为非阻塞的。阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。socket的基础API中，可能被阻塞的系统调用包括accept、send、recv和connect。
- 针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时我们必须根据errno来区分这两种情况。对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS（意为“在处理中”）。
- 很显然，我们只有在事件已经发生的情况下操作非阻塞I/O（读、写等），才能提高程序的效率。因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。
- I/O复用是最常使用的I/O通知机制。**它指的是，应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。**Linux上常用的I/O复用函数是select、poll和epoll_wait。需要指出的是，I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。

